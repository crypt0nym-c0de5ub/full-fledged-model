

% ==================================================
%                 differential trails
% ==================================================
% Basic Constraint
constraint forall(r in 0..Rb+Ru+Rm-1, i in 0..15)(
  uXAK[r,i] >= uYAK[r,i] /\
  uXSB[r,i] >= uYSB[r,i] /\
  uXSR[r,i] >= uYSR[r,i]
);
constraint forall(r in Rb+Ru+1..Rb+Ru+Rm+Rl+Rf, i in 0..15)(
  lXAK[r,i] >= lYAK[r,i] /\
  lXSB[r,i] >= lYSB[r,i] /\
  lXSR[r,i] >= lYSR[r,i]
);

% ======================= Upper =======================
% === Add Round Tweakey ===
constraint forall(r in 0..Rb+Ru+Rm-1, i in 0..15)(
  AddRoundTweakey(uXAK[r,i], uYAK[r,i], uSTK[r,i], uXSB[r,i], uYSB[r,i], uCAN[r,i])
);

% === Sbox Substitution ===
constraint forall(r in 0..Rb+Ru-1, i in 0..15)(
  SboxSubstitution(uXSB[r,i], uYSB[r,i], uXSR[r,i], uYSR[r,i])
);
constraint forall(r in 0..Rb-1, i in 0..15)(
% exclude where "None-Zero Fixed <-(SB)- Truncated"
  uYSB[r,i] >= uYSR[r,i]
);

% === Sbox for **Rm** ===
constraint forall(r in Rb+Ru..Rb+Ru+Rm-1, i in 0..15)(
  SboxSubstitutionMiddle(uXSB[r,i], uYSB[r,i], uXSR[r,i], uYSR[r,i])
);

% === ShifrRow & MixColumn ===
constraint forall(r in 0..Rb+Ru+Rm-1, j in 0..3)(
  Mixcolumn(uXSR[r,SRp[4*j]], uXSR[r,SRp[4*j+1]], uXSR[r,SRp[4*j+2]], uXSR[r,SRp[4*j+3]], 
            uXAK[r+1,4*j],    uXAK[r+1,4*j+1],    uXAK[r+1,4*j+2],    uXAK[r+1,4*j+3],
            uAC[r,j])
  /\
  Mixcolumn(uYSR[r,SRp[4*j]], uYSR[r,SRp[4*j+1]], uYSR[r,SRp[4*j+2]], uYSR[r,SRp[4*j+3]], 
            uYAK[r+1,4*j],    uYAK[r+1,4*j+1],    uYAK[r+1,4*j+2],    uYAK[r+1,4*j+3],
            uTC[r,j])
);

% Fix some patterns (the difference in distinguisher is fixed)
constraint forall(r in Rb..Rb+Ru-1, i in 0..15)(
  (uYAK[r,i] = 0)
  /\
  (uYSB[r,i] = 0)
  /\
  (uYSR[r,i] = 0)
);

% ===== key schedule =====
constraint forall(i in 0..15, r in 0..Rb+Ru+Rm)(uLANE[i] >= uSTK[r,hTable[i,r]]);
constraint forall(i in 0..15)(sum(r in 0..Rb+Ru+Rm)(uSTK[r,hTable[i,r]]) >= ((Rb+Ru+Rm+1) * uLANE[i]) - (SpecDeoxys-1));

constraint forall(r in 0..Rb+Ru, j in 0..3)(4*uAC[r,j] - uXAK[r+1,4*j] - uXAK[r+1,4*j+1] - uXAK[r+1,4*j+2] - uXAK[r+1,4*j+3] - uPasDeg[r,j] = 0);
constraint forall(r in 0..Rb+Ru, j in 0..3)((uCanDeg[r,j] + uXSR[r,SRp[4*j]] + uXSR[r,SRp[4*j+1]] + uXSR[r,SRp[4*j+2]] + uXSR[r,SRp[4*j+3]]
                                                  - uPasDeg[r,j] - uCAN[r+1,4*j] - uCAN[r+1,4*j+1] - uCAN[r+1,4*j+2] - uCAN[r+1,4*j+3] >= 0) 
                                                  /\ 
                                                  uCanDeg[r,j] >= 0);
constraint -(Rb+Ru+Rm-SpecDeoxys+1) * sum(i in 0..15)(uLANE[i]) 
           - sum(r in 0..Rb+Ru, j in 0..3)(uCanDeg[r,j]) 
           + sum(r in 0..Rb+Ru+Rm, i in 0..15)(uSTK[r,i]) >= 1;
           
constraint sum(i in 0..15)(uLANE[i]) >= 1;



% ======================= Lower =======================

%===== OPERATION: Add Round Tweakey =====%
constraint forall(r in Rb+Ru+1..Rb+Ru+Rm+Rl+Rf-1, i in 0..15)(
  AddRoundTweakey(lXAK[r,i], lYAK[r,i], lSTK[r,i], lXSB[r,i], lYSB[r,i], lCAN[r,i])
);

%===== OPERATION: Sbox Substitution =====%
% Sbox for Rm
constraint forall(r in Rb+Ru..Rb+Ru+Rm-1, i in 0..15)(
  SboxSubstitutionMiddle(lXSR[r,i], lYSR[r,i], lXSB[r,i], lYSB[r,i])
);
constraint forall(r in Rb+Ru+Rm..Rb+Ru+Rm+Rl+Rf-1, i in 0..15)(
  SboxSubstitution(lXSB[r,i], lYSB[r,i], lXSR[r,i], lYSR[r,i])
);
constraint forall(r in Rb+Ru+Rm+Rl..Rb+Ru+Rm+Rl+Rf-1, i in 0..15)(
% exclude where "Truncated -(SB)-> Nono-Zero Fixed"
  lYSR[r,i] >= lYSB[r,i]
);

constraint forall(r in Rb+Ru..Rb+Ru+Rm+Rl+Rf-1, j in 0..3)(
  Mixcolumn(lXSR[r,SRp[4*j]], lXSR[r,SRp[4*j+1]], lXSR[r,SRp[4*j+2]], lXSR[r,SRp[4*j+3]], 
            lXAK[r+1,4*j],    lXAK[r+1,4*j+1],    lXAK[r+1,4*j+2],    lXAK[r+1,4*j+3],
            lAC[r,j])
  /\
  Mixcolumn(lYSR[r,SRp[4*j]], lYSR[r,SRp[4*j+1]], lYSR[r,SRp[4*j+2]], lYSR[r,SRp[4*j+3]], 
            lYAK[r+1,4*j],    lYAK[r+1,4*j+1],    lYAK[r+1,4*j+2],    lYAK[r+1,4*j+3],
            lTC[r,j])
);

% Fix some patterns (the difference in distinguisher is fixed)
constraint forall(r in Rb+Ru+Rm..Rb+Ru+Rm+Rl-1, i in 0..15)(
  (lYAK[r,i] = 0)
  /\
  (lYSB[r,i] = 0)
  /\
  (lYSR[r,i] = 0)
);

% the round before the last one should not be fully active
constraint sum(i in 0..15)(lXSB[Rb+Ru+Rm+Rl+Rf-2, i]) <= 15;

% =============== key schedule ===============
constraint forall(i in 0..15, r in Rb+Ru..Rb+Ru+Rm+Rl+Rf)(lLANE[i] >= lSTK[r,hTable[i,(r mod 16)]]);
constraint forall(i in 0..15)(sum(r in Rb+Ru..Rb+Ru+Rm+Rl+Rf)(lSTK[r,hTable[i,(r mod 16)]]) >= ((Rm+Rl+Rf+1) * lLANE[i]) - (SpecDeoxys-1));

constraint forall(r in Rb+Ru+Rm-1..Rb+Ru+Rm+Rl+Rf-1, j in 0..3)(4*lAC[r,j] - lXAK[r+1,4*j] - lXAK[r+1,4*j+1] - lXAK[r+1,4*j+2] - lXAK[r+1,4*j+3] - lPasDeg[r,j] = 0);
constraint forall(r in Rb+Ru+Rm-1..Rb+Ru+Rm+Rl+Rf-1, j in 0..3)(lCanDeg[r,j] + lXSR[r,SRp[4*j]] + lXSR[r,SRp[4*j+1]] + lXSR[r,SRp[4*j+2]] + lXSR[r,SRp[4*j+3]]
                                                           - lPasDeg[r,j] - lCAN[r+1,4*j] - lCAN[r+1,4*j+1] - lCAN[r+1,4*j+2] - lCAN[r+1,4*j+3] >= 0
                                                           /\
                                                           lCanDeg[r,j] >= 0);
           
constraint -(Rl+Rf+Rm-SpecDeoxys+1) * sum(i in 0..15)(lLANE[i]) 
           - sum(r in Rb+Ru+Rm-1..Rb+Ru+Rm+Rl+Rf-1, j in 0..3)(lCanDeg[r,j])
           + sum(r in Rb+Ru..Rb+Ru+Rm+Rl+Rf, i in 0..15)(lSTK[r,i]) >= 1;
           
constraint sum(i in 0..15)(lLANE[i]) >= 1;

% Tables for Em
constraint forall(r in Rb+Ru..Rb+Ru+Rm-1, i in 0..15)(
  BuildTables(uXSB[r,i], uYSB[r,i], uXSR[r,i], uYSR[r,i], 
              lXSB[r,i], lYSB[r,i], lXSR[r,i], lYSR[r,i],
              Ta[r,i], Tb[r,i])
);

% --- Probability calculation of each part ---
constraint PrEb = sum([14*(uXSB[r,i] - uYSB[r,i]) | r in 0..Rb-1, i in 0..15] ++ 
                      [16*(4*uTC[r,c] - sum(i in 0..3)(uYSR[r,SRp[4*c+i]])) | r in 0..Rb-1, c in 0..3]);

% no truncated difference of a column in the distinguisher
constraint PrEu = sum([14*(uXSB[r,i] - uYSB[r,i]) | r in Rb..Rb+Ru-1, i in 0..15]);
% dedicated for 2 round Em using DBCT
constraint PrEm = sum([6*(Ta[r,i]) | r in Rb+Ru..Rb+Ru+Rm-1, i in 0..15] ++ 
                      [14*(Tb[r,i]) | r in Rb+Ru..Rb+Ru+Rm-1, i in 0..15] ++ 
                      [16*(4*uTC[r,c] - sum(i in 0..3)(uYAK[r+1,4*c+i])) | r in Rb+Ru..Rb+Ru+Rm-2, c in 0..3] ++ 
                      [16*(4*lTC[r,c] - sum(i in 0..3)(lYSR[r,SRp[4*c+i]])) | r in Rb+Ru..Rb+Ru+Rm-2, c in 0..3]);

% no truncated difference of a column in the distinguisher
constraint PrEl = sum([14*(lXSB[r,i] - lYSB[r,i]) | r in Rb+Ru+Rm..Rb+Ru+Rm+Rl-1, i in 0..15]);

constraint PrEf = sum([14*(lXSR[r,i] - lYSR[r,i]) | r in Rb+Ru+Rm+Rl..Rb+Ru+Rm+Rl+Rf-1, i in 0..15] ++ 
                      [16*(4*lTC[r-1,c] - sum(i in 0..3)(lYAK[r,4*c+i])) | r in Rb+Ru+Rm+Rl+1..Rb+Ru+Rm+Rl+Rf, c in 0..3]);


% ====== Boundary and Involved =======

%== Add RoundKey ==
constraint forall(r in 0..Rb-1, i in 0..15)(
  (uVAK[r,i] = uVSB[r,i]) /\ (uVSTK[r,i] = uVSB[r,i])
);
%== Sbox Substitution ==
constraint forall(r in 0..Rb-1, j in 0..3, i in 0..3)(
  Boundaries_SB(uXSB[r,SRp[4*j+i]], uYSB[r,SRp[4*j+i]], uVSB[r,SRp[4*j+i]], 
                uXSR[r,SRp[4*j+i]], uYSR[r,SRp[4*j+i]], uVSR[r,SRp[4*j+i]], 
                uBND[r,SRp[4*j+i]], uVC[r,j]));
%== MixColumn ==
constraint forall(r in 1..Rb, j in 0..3)(
  Boundaries_MC(uVAK[r, 4*j], uVAK[r, 4*j+1], uVAK[r, 4*j+2], uVAK[r, 4*j+3], uVC[r-1,j]));



% ===== OPERATION: Sbox Substitution ===== %
constraint forall(r in Rb+Ru+Rm+Rl..Rb+Ru+Rm+Rl+Rf-1, j in 0..3, i in 0..3)
  (Boundaries_SB(lXSR[r,4*j+i], lYSR[r,4*j+i], lVSR[r,4*j+i],
                 lXSB[r,4*j+i], lYSB[r,4*j+i], lVSB[r,4*j+i],
                 lBND[r,4*j+i], lVC[r-1,j]));

% ===== OPERATION: ShiftRow ===== %                         
constraint forall(r in Rb+Ru+Rm+Rl..Rb+Ru+Rm+Rl+Rf-1, i in 0..15)
  (lVMC[r,i] = lVSR[r,SRp[i]]);
  
% ===== OPERATION: MixColumn ===== %
constraint forall(r in Rb+Ru+Rm+Rl..Rb+Ru+Rm+Rl+Rf-1, j in 0..3)
  (Boundaries_MC(lVMC[r, 4*j], lVMC[r, 4*j+1], lVMC[r, 4*j+2], lVMC[r, 4*j+3], lVC[r,j]));
  
% ===== OPERATION: Add RoundKey (eqtk) =====%
constraint forall(r in Rb+Ru+Rm+Rl..Rb+Ru+Rm+Rl+Rf-1, j in 0..3, i in 0..3)
  (lVAK[r+1,4*j+i] = lVC[r,j] /\ lVSR[r,4*j+i] = lVSTK[r+1,4*j+i]);
  
% ===== The end of Eb and the beginning of Ef, we have VC = 0 =====
constraint sum(i in 0..3)(uVC[Rb-1,i]) = 0 /\ sum(i in 0..3)(lVC[Rb+Ru+Rm+Rl-1,i]) = 0;


constraint VSTK_SUM = sum(r in 0..Rb-1, i in 0..15)(uVSTK[r,i]) + 
                      sum(r in Rb+Ru+Rm+Rl+1..Rb+Ru+Rm+Rl+Rf, i in 0..15)(lVSTK[r,i]);




